import { LogTypes } from "./Logger";
import { SpaceUserInfo, Space, SpawnPoint, Portal, Announcer, WireArea, PlayerUpdatesSession, EditChatMessage } from "@gathertown/gather-game-common/dist/src/public/events";
import { EnabledChat, GameMap, GameMapV2, MapObject, TutorialTasks, WallFloorBlock } from "@gathertown/gather-game-common/dist/src/public/gameMap";
import { PartialGameState } from "@gathertown/gather-game-common/dist/src/public/gameState";
import { MoveDirection, Player, SpriteDirection } from "@gathertown/gather-game-common/dist/src/public/player";
import { ServerClientEventByCase, ServerClientEventCase } from "@gathertown/gather-game-common/dist/src/public/utils";
import { Engine, EngineAuth } from "./Engine";
import { ServerClientEventContext } from "./Utils";
export * from "@gathertown/gather-game-common/dist/src/public/events";
export * from "@gathertown/gather-game-common/dist/src/public/factories";
export * from "@gathertown/gather-game-common/dist/src/public/gameMap";
export * from "@gathertown/gather-game-common/dist/src/public/gameState";
export * from "@gathertown/gather-game-common/dist/src/public/player";
export * from "@gathertown/gather-game-common/dist/src/public/position";
export * from "@gathertown/gather-game-common/dist/src/public/responseCodes";
export * from "@gathertown/gather-game-common/dist/src/public/remoteWork";
export * from "@gathertown/gather-game-common/dist/src/public/utils";
declare type GameSpaceSubscription = Readonly<{
    onMap: (id: string, map: GameMap) => void;
}>;
declare type GameEventSubscriptions<T extends ServerClientEventCase> = {
    [uuid: string]: (data: ServerClientEventByCase<T>, context: ServerClientEventContext) => void;
};
export declare type GameEventSubscriptionMap = {
    [eventId in ServerClientEventCase]?: GameEventSubscriptions<eventId>;
};
export declare type GameOptions = {
    logLevels?: LogTypes;
    overrideServer?: string;
};
export declare class Game {
    spaceId?: string;
    engine: Engine;
    connected: boolean;
    getAuth: () => Promise<EngineAuth>;
    private subscriptionFinishedCallback;
    private subscriptionFailedCallback;
    private updateSubscriptionsPromise;
    private _initializedAtMs;
    private _connectedAtMs;
    private hasSentMapSinceConnect;
    private timeToFirstOnMapsMs;
    private _onMapCounts;
    private _connectCalledAt;
    private _timeToConnect;
    debugOverrideServer?: string;
    private subscriptions;
    private disconnectHandlers;
    legacySubscriptions: {
        [uuid: string]: GameSpaceSubscription;
    };
    legacySubscriptionsConnection: {
        [uuid: string]: (connected: boolean) => void;
    };
    private eventSubscriptions;
    private _encIdMapping;
    players: {
        [uid: string]: Player;
    };
    dispatchGameUpdate?: (delta: PartialGameState<Player>) => void;
    dispatchMapUpdate?: (mapId: string, map: Readonly<GameMapV2>) => void;
    private mapsAccumulator;
    completeMaps: {
        [id: string]: GameMapV2;
    };
    partialMaps: {
        [id: string]: Partial<GameMapV2>;
    };
    lastMapUpdateIds: {
        [id: string]: number;
    };
    onInput: ((dir: MoveDirection, stopped: boolean, inputId: number) => void) | undefined;
    inputId: number;
    private mapDataChecks;
    private mapDataCheckInterval;
    putMetric: (metricName: string, metricValue: any) => void;
    debug(debugState?: boolean): void;
    constructor(spaceId: string | undefined, getAuth: () => Promise<EngineAuth>, onInput?: (dir: MoveDirection, stopped: boolean, inputId: number) => void, dispatchGameUpdate?: (delta: PartialGameState<Player>) => void, dispatchMapUpdate?: (mapId: string, map: Readonly<GameMapV2>) => void, options?: GameOptions);
    init(spaceId: string, _overrideServer?: string): void;
    _setupEngineCallbacks(): void;
    connect(): Promise<void> | undefined;
    waitForInit(): Promise<void>;
    disconnect(): void;
    getPlayer(uid: string): Player | undefined;
    publishEvent<T extends ServerClientEventCase>(eventId: T, data: ServerClientEventByCase<T>, context: ServerClientEventContext): void;
    subscribeToEvent<T extends ServerClientEventCase>(eventId: T, handler: (data: ServerClientEventByCase<T>, context: ServerClientEventContext) => void): () => void;
    subscribeToSpace(space: string, listeners: GameSpaceSubscription): () => void;
    subscribeToConnection(callback: (connected: boolean) => void): () => void;
    subscribeToDisconnection(callback: (code?: number, reason?: string) => void): () => void;
    enter(info: SpaceUserInfo, spawnToken?: string, targetId?: string): void;
    exit(): void;
    respawn(): void;
    spawn(spawnToken: string): void;
    move(dir: MoveDirection, stopped?: boolean, targetId?: string): void;
    playSound(src: string, volume: number, targetId?: string): void;
    ghost(ghost: number, targetId?: string): void;
    enterWhisper(recipientId: string, dir: MoveDirection): void;
    leaveWhisper(): void;
    teleport(mapId: string, x: number, y: number, targetId?: string, direction?: SpriteDirection): void;
    ring(user: string): void;
    block(blockedUserId: string, blocked: boolean): void;
    pointer(objectId: string, x: number, y: number): void;
    screenPointer(screenId: string, x: number, y: number): void;
    setActivelySpeaking(activelySpeaking: boolean): void;
    setEmote(emote: string | undefined, targetId?: string): void;
    setOpenToConversation(openToConversation: boolean, targetId?: string): void;
    setWorkCondition(workCondition: boolean, targetId?: string): void;
    setName(name: string, targetId?: string): void;
    setIsMobile(isMobile: boolean): void;
    setTextStatus(textStatus: string, targetId?: string): void;
    setEmojiStatus(emojiStatus: string, targetId?: string): void;
    setAffiliation(affiliation: string, targetId?: string): void;
    setStatus(status: boolean, targetId?: string): void;
    setEventStatus(eventStatus: string, targetId?: string): void;
    setInConversation(inConversation: boolean, targetId?: string): void;
    setCurrentDesk(currentDesk: string, targetId?: string): void;
    setCurrentArea(currentArea: string, targetId?: string): void;
    setOutfitString(outfitString: string, targetId?: string): void;
    clearItem(targetId?: string): void;
    setItem(itemId: string, itemImage: string, targetId?: string): void;
    triggerItem(closestObject?: string, closestObjectTemplate?: string, targetId?: string): void;
    setSpotlight(user: string, spotlighted: boolean): void;
    banPlayer(user: string): void;
    kickPlayer(user: string): void;
    interact(objId: string, data?: any): void;
    chat(chatRecipient: string, localPlayers: string[], mapId: string, data: {
        id?: string;
        contents: string;
    }): void;
    editChatMessage(message: EditChatMessage): void;
    notify(notification: string): void;
    shootConfetti(targetId?: string): void;
    setGoKartId(goKartId: string, targetId?: string): void;
    setIsAlone(isAlone: boolean, targetId?: string): void;
    setFocusModeEndTime(focusModeEndTime: string, targetId?: string): void;
    setFollowTarget(followTarget: string): void;
    enterPortal(targetUrl: string, targetId?: string, bypassPrompt?: boolean): void;
    setMapDimensions(mapId: string, width: number, height: number): void;
    setMapCollisions(mapId: string, x: number, y: number, w: number, h: number, mask: string): void;
    setMapBackgroundImagePath(mapId: string, backgroundImagePath: string): void;
    setMapForegroundImagePath(mapId: string, foregroundImagePath: string): void;
    setMapSprites(mapId: string, sprites: number[]): void;
    setMapSpawns(mapId: string, spawns: SpawnPoint[]): void;
    setMapSpaces(mapId: string, spaces: Space[]): void;
    setMapPortals(mapId: string, portals: Portal[]): void;
    setMapAnnouncer(mapId: string, announcer: Announcer[]): void;
    setMapObjects(mapId: string, objects: {
        [key: number]: Partial<MapObject>;
    }, updatesAreOverwrites?: boolean): void;
    moveMapObject(mapId: string, objectId: string, targetWorldPos: {
        x: number;
        y: number;
        xOffset?: number;
        yOffset?: number;
    }, durationMs: number, easing?: "Linear" | "Cubic" | "Elastic" | "Bounce" | "Back"): void;
    setMapName(mapId: string, name: string): void;
    setMapMuteOnEntry(mapId: string, muteOnEntry: boolean): void;
    setMapUseDrawnBG(mapId: string, useDrawnBG: boolean): void;
    setMapWalls(mapId: string, walls: WallFloorBlock[]): void;
    setMapFloors(mapId: string, floors: WallFloorBlock[]): void;
    setMapAreas(mapId: string, areas: {
        [areaName: string]: WireArea;
    }): void;
    setMapMiniMapImagePath(mapId: string, miniMapImagePath: string): void;
    setMapEnabledChats(mapId: string, enabledChats: EnabledChat[]): void;
    setMapDescription(mapId: string, description: string): void;
    setMapDecoration(mapId: string, decoration: string): void;
    setMapTutorialTasks(mapId: string, tutorialTasks: TutorialTasks): void;
    setImpassable(mapId: string, x: number, y: number, impassable?: boolean): void;
    getObject(objId: string, mapId?: string): {
        mapId: string;
        obj: MapObject | undefined;
    } | null;
    setObject(mapId: string, objId: string, obj: Partial<MapObject>, useTxnId?: boolean): void | Promise<unknown>;
    deleteObjectByKey(mapId: string, key: number, createTxnId?: boolean): Promise<unknown>;
    deleteObject(mapId: string, objId: string, createTxnId?: boolean): Promise<unknown>;
    requestToLead(target: string, snapshot?: string): Promise<void>;
    setManualVideoSrc(manualVideoSrc: string, targetId?: string): void;
    setSubtitle(subtitle: string, targetId?: string): Promise<void>;
    getStats(): {
        serverURL: string;
        engine: {
            connected: boolean;
            latency: import("./Utils").SlidingWindowMetrics;
            reconnects: {
                recentAttempts: number;
                timeSpentDisconnectedMs: import("./Utils").SlidingWindowMetrics;
            };
            bufferedAmount: import("./Utils").SlidingWindowMetrics;
            bytesSentSinceConnect: number;
            bytesReceivedSinceConnect: number;
            eventCountsSinceOpen: {
                [event: string]: number;
            };
            closeCodeCount: {
                [code: number]: number;
            };
        };
        wsReadyState: number | undefined;
        timeToConnect: number;
        timeToFirstOnMapMs: {
            [mapId: string]: number;
        };
        onMapCountsAllTime: {
            [mapId: string]: number;
        };
        gameClientAgeMs: number;
        numPlayers: number;
        preferredRegion: string | undefined;
        preferredRegionPing: number;
        currentMap: string | undefined;
        gameClientVersion: string;
    };
    subscribeToAll(): void;
    _startMapDataCheckInterval(): void;
    getDebugHistory(): string;
    getPlayersInMap(mapId: string): Player[];
    getKnownPartialMaps(): string[];
    getKnownCompletedMaps(): string[];
    filterObjectsInMap(mapId: string, filter: (obj: Partial<MapObject>) => boolean): MapObject[];
    filterPlayersInSpace(filter: (player: Partial<Player>) => boolean): Player[];
    patchGatherEventsSpaceSession(playerUpdatesSession: PlayerUpdatesSession): void;
    isPlayerInPrivateSpace: (player: Partial<Player>, mapId: string, privateSpaceId: string) => boolean;
}
