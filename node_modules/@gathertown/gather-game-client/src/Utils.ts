import { GameMapV2 } from "@gathertown/gather-game-common/dist/src/public/gameMap";
import { Player } from "@gathertown/gather-game-common/dist/src/public/player";
import axios from "axios";
import { shuffle } from "lodash";
import { API_BASE_PATH } from "./config";
import { logger } from "./Logger";

export const isBrowser = typeof window !== "undefined";

export interface SlidingWindowMetrics {
  min: number;
  max: number;
  avg: number;
  last: number;
}

export interface ServerClientEventContext {
  /**
   * The space this client is operating on. Mostly for convenience
   */
  spaceId: string;
  /**
   * If encId is present on the incoming event, then _player_ will be populated here. You are not guaranteed completeness in the player object, some fields may be undefined.
   */
  player?: Partial<Player>;
  /**
   * If encIdTarget is present on the incoming event, then _target_ will be populated. You are not guaranteed completeness, just like player; it's whatever is in the state.
   */
  target?: Partial<Player>;
  /**
   * The uid of the player, if present.
   */
  playerId?: string;
  /**
   * The uid of the target, if present.
   */
  targetId?: string;
  /**
   * If mapId is present on the incoming event, then _map_ will be populated. You are not guaranteed completeness in the map object.
   */
  map?: Partial<GameMapV2>;
}

export class SlidingWindow {
  maxSize: number;
  values: number[] = [];
  _minValue?: number;
  _maxValue?: number;
  _lastValue?: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }

  push(value: number) {
    this._lastValue = value;
    this.values.push(value);
    if (this.values.length > this.maxSize) {
      this.values.shift();
    }
    if (typeof this._minValue === "undefined" || value < this._minValue) {
      this._minValue = value;
    }
    if (typeof this._maxValue === "undefined" || value > this._maxValue) {
      this._maxValue = value;
    }
  }

  getLast() {
    return this._lastValue;
  }

  getAverage() {
    if (!this.values.length) {
      return undefined;
    }
    const avg = this.values.reduce((acc, v) => v + acc, 0) / this.values.length;
    return parseFloat(avg.toFixed(2));
  }

  getMin() {
    if (!this._minValue) {
      return undefined;
    }
    return parseFloat(this._minValue.toFixed(2));
  }

  getMax() {
    if (!this._maxValue) {
      return undefined;
    }
    return parseFloat(this._maxValue?.toFixed(2));
  }

  getMetrics(): SlidingWindowMetrics {
    return {
      max: this.getMax() || -1,
      avg: this.getAverage() || -1,
      min: this.getMin() || -1,
      last: this.getLast() || -1,
    };
  }
}

/**
 * Ping test a random server in each Region
 * @returns Object | undefined
 */
export const findClosestRegion = async () => {
  const gameServers = await getGameServers();
  if (!(gameServers instanceof Array)) {
    logger.error("failed to get game servers");
    return;
  }

  // pick one random? server per region
  const gsMap = shuffle(gameServers).reduce((prev, c) => {
    if (!c.region || c.region in prev) {
      return prev;
    }
    prev[c.region] = c.hostname;
    return prev;
  }, {});

  // ping test
  let minPing = Infinity;
  let closestRegion: string | undefined = undefined;
  for (const region in gsMap) {
    const hostname = gsMap[region];
    const url = hostname === "localhost" ? "/__dev-gs-api/ping" : `https://${hostname}:443/ping`;
    const start = Date.now();
    await axios.get(url).catch((e) => logger.error(logger.errString(e)));
    const ping = Date.now() - start;
    if (ping < minPing) {
      minPing = ping;
      closestRegion = region;
    }
  }
  if (!closestRegion) {
    logger.error("Failed ping test for closest region. " + Object.keys(gsMap));
    return;
  }

  logger.debug(`preferred region ${closestRegion} ping: ${minPing}ms`);

  return {
    closestRegion,
    ping: minPing,
  };
};

export const getGameServers = async () => {
  const url = isBrowser
    ? `${API_BASE_PATH}/api/v2/game-servers`
    : `https://gather.town/api/v2/game-servers`;
  try {
    const res = await axios.get(url);
    return res?.data;
  } catch (e) {
    // @ts-expect-error Error auto-ignored when enabling useUnknownInCatchVariables. It's possible this is incorrect.
    // TODO: @ENG-4157 Clean these up! If you're already touching this code, please clean this up while you're at it.
    logger.error(e);
  }
};

export const fetchGameServerAssignment = async (space: string, preferredRegion?: string) => {
  const res = await axios.get(
    // on browser, use the same deployment that we're currently using
    // from the api, always use prod
    isBrowser
      ? `${API_BASE_PATH}/api/v2/spaces/${encodeURIComponent(space)}/game-server-assignment`
      : `https://gather.town/api/v2/spaces/${encodeURIComponent(space)}/game-server-assignment`,
    {
      params: {
        body: {
          preferredRegion,
        },
      },
    },
  );

  return res?.data;
};

export const sleepAndReject = (n: number, message?: string) => {
  return new Promise((_, reject) => {
    setTimeout(() => reject(message), n);
  });
};

export const parseCustomAction = <ActionType>(name: string, payload: string): ActionType => {
  let action: ActionType;
  try {
    action = JSON.parse(payload);
  } catch {
    throw new Error(`Failed to parse payload for ${name} event: ${payload}`);
  }
  return action;
};
